---
layout:     post
title:      【BFS 结构体 队列】2021年浙江理工大学新生赛 C nudun故事集之ATM开路
subtitle:   
date:       2021.12.14
author:     追殇
header-img: 
catalog:   true
tags:
    - C++
---
**题目背景**
单身富豪widow想要走过这条路，经nudun的介绍找来了ATM来帮忙开路，ATM被迫成为了苦力工，途中有好多障碍，而ATM体力有限，最多只能推倒一个障碍，请问ATM能为widow提供的最短距离是多少
**题目描述**
有一个`n*m`的`01`矩阵，其中`0`表示空地，`1`表示障碍，求从起点`s`走到终点`t`最多经过`1`次障碍的最短距离。
**输入**
第一行输入`6`个正整数`n，m，x1，y1，x2，y2`（`1<=x1,x2<=n<=50`，`1<=y1,y2<=m<=50`），代表矩阵的大小为`n*m`，起点`s`的位置为`(x1,y1)`，终点t的位置为`(x2,y2)`，题目保证`s`和`t`一定是一个空地
接下来`n`行，第`i`行输入一个长度为`m`的`01`串代表矩阵的第`i`行
**输出**
第一行输出最短距离，如果无法从`s`到达`t`，输出`-1`
**样例输入**

```cpp
3 3 1 1 3 3
000
111
000
```

**样例输出**

```cpp
4
```

## 广度优先搜索

**广度优先搜索**( BFS, Breadth-First Search )按照开始状态→只需1次转移就可以到达的所有状态→只需2次转移就可以到达的所有状态……这样的顺序进行搜索。对于同一一个状态， 宽度优先搜索只经过一次，因此复杂度为O(状态数*转移的方式)。

广度优先搜索利用了队列。首先将初始状态添加到队列，此后从队首不断取出状态，**将从该状态可以转移到的状态中尚未访问过的部分加入队列**，如此反复直到队列为空或找到问题的解。

在本题中，使用`maze[MAX_N][MAX_M+1]`存整张地图，`d[MAX_N][MAX_M][2]`表示到当每个点的最短路径。其中，`d[nx][ny][0]`表示前面一直没碰到障碍，`d[nx][ny][1]`表示前面遇到了一次障碍并且穿过了障碍。

另一个小知识点是结构体与队列的混合运用。

具体细节见代码和注释。

## PS1：请注意，`memset`按照`1`字节为单位对内存进行填充，不能对`int`数组初始化成除了`0,-1`之外的值。
## 对于除了0,-1之外的数，建议手动初始化。
## PS2：`-1`能被初始化的原因是`-1`的每一位二进制位都是`1`
**例如：**

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int main(){
    int a[100];
    memset(a,0,sizeof(a)); cout<<a[0]<<" "<<a[1]<<endl;
    memset(a,-1,sizeof(a)); cout<<a[0]<<" "<<a[1]<<endl;
    memset(a,1,sizeof(a)); cout<<a[0]<<" "<<a[1]<<endl;
    memset(a,2,sizeof(a)); cout<<a[0]<<" "<<a[1]<<endl;
    memset(a,3,sizeof(a)); cout<<a[0]<<" "<<a[1]<<endl;
    return 0;
}
```
**输出结果：**
![输出结果](https://img-blog.csdnimg.cn/203fa6d95dda427ca5fb52fd0f3e614f.png)

**`AC` 代码**

```cpp
#include<iostream>
#include<queue>
using namespace std;
const int INF=(1<<28),MAX_N=51,MAX_M=51;

struct node{
    int nx,ny,mark;
};

char maze[MAX_N][MAX_M+1];//存地图 
int N,M,sx,sy,gx,gy;//s起点,g终点 
int d[MAX_N][MAX_M][2];//表示到各个点的最短距离 
int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};//用于dfs的方向向量 

int check(int nx,int ny,int mark){//检查边界条件 
    if(0<=nx and nx<N and 0<=ny and ny<M and d[nx][ny][mark]==INF){
        if(maze[nx][ny]=='1' and mark==0) return 2;//遇到墙,但前面没遇到墙 
        if(maze[nx][ny]=='0') return 1;//畅通 
    }
    return 0;
}

int bfs(){
    for(int i=0;i<N;i++)
        for(int j=0;j<M;j++){
            d[i][j][0]=INF;
            d[i][j][1]=INF;
        }
    queue<node> que;
    que.push((node){sx,sy,0});//起点入队 
    d[sx][sy][0]=0;//起点距离为0 
    
    while(que.size()){//不断循环直到队列为空 
        node p=que.front();//读取队首 
        que.pop();//弹出队首 
        if(p.nx==gx and p.ny==gy) break;//抵达终点 
        for(int i=0;i<4;i++){
            int nx=p.nx+dx[i],ny=p.ny+dy[i],mark=p.mark;//新位置为nx,ny 
            if(check(nx,ny,mark)==1){//可以移动 
                que.push((node){nx,ny,mark});//加入队尾 
                d[nx][ny][mark]=d[p.nx][p.ny][mark]+1;//距离+1 
            }
            else if(check(nx,ny,mark)==2){//遇到障碍,允许第一次穿过 
                mark=1;
                que.push((node){nx,ny,mark});
                d[nx][ny][mark]=d[p.nx][p.ny][0]+1;
            }
        }
    }
    return min(d[gx][gy][0],d[gx][gy][1]);
}

int main(){
    cin>>N>>M>>sx>>sy>>gx>>gy;
    sx--;sy--;gx--;gy--;//修正所给数据以符合存图的习惯 
    for(int i=0;i<N;i++)
        for(int j=0;j<M;j++)
            cin>>maze[i][j];
    int res=bfs();
    if(res==INF)cout<<-1;
    else cout<<res;
    return 0;
} 
```
